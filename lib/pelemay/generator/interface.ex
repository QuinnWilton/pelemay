defmodule Pelemay.Generator.Interface do
  alias Pelemay.Generator
  alias Pelemay.Db
  alias Pelemay.Generator

  require Logger

  def generate(module) when is_atom(module) do
    case generate_functions(module) do
      "" ->
        {:error, "Don't need defpelemay"}

      funcs ->
        bench = generate_bench(module)

        str = """
        # This file was generated by Pelemay.Generator.Interface
        defmodule #{Generator.nif_module(module)} do
          @compile {:autoload, false}
          @on_load :init

          require Logger

          def init do
            init_cpu_info()
            load_nifs()
            register_module()
            :ok
          end

          def load_nifs do
            nif_file = "\#{Pelemay.Generator.libnif(#{module})}"
            Logger.debug("[Pelemay] library.exists? = \#{Path.wildcard(\"\#{nif_file}\.{dll,so}\") |> File.exists?()}")
            case :erlang.load_nif(nif_file, 0) do
              :ok ->
                Logger.debug("[Pelemay] load_nif success")
                :ok
              other -> Logger.debug(#{~S/"[Pelemay] Failed to load NIF:#{other}"/})
            end
          end

          def init_cpu_info do
            :ets.new(:cpu_info, [:set, :public, :named_table])
            :ets.insert(:cpu_info, {:runtime_info, CpuInfo.all_profile()})
            Logger.debug("[Pelemay] init_cpu_info success")
          end

          def register_module() do
            try do
              Logger.debug("[Pelemay] append pelemay_if \#{__MODULE__}")
              :ets.insert(
                :pelemay_if, 
                {
                  :modules, 
                  Map.put(
                    Keyword.get(:ets.lookup(:pelemay_if, :modules), :modules),
                    __MODULE__,
                    true
                  )
                }
              )
            rescue
              _e in ArgumentError ->
                Logger.debug("[Pelemay] init pelemay_if")
                :ets.new(:pelemay_if, [:set, :public, :named_table])
                Logger.debug("[Pelemay] append pelemay_if \#{__MODULE__}")
                :ets.insert(
                  :pelemay_if, 
                  {
                    :modules, 
                    [{__MODULE__, true}] |> Map.new()
                  }
                )
            end
          end

        #{bench}

        #{funcs}
        end
        """

        Generator.stub(module) |> File.write(str)
        Generator.stub(module) |> Code.compile_file(Generator.ebin())

        Code.append_path(Generator.ebin())
        :ok
    end
  end

  defp generate_bench(module) do
    driver_lsms =
      Db.get_functions()
      |> Enum.map(&get_driver_lsms(module, &1))
      |> List.flatten()

    """
      def bench() do
        [
    #{
      driver_lsms
      |> Enum.map(&generate_driver_driver(&1))
      |> Enum.join("\n")
    }
        ]
      end
    """
  end

  def generate_driver_driver(driver_lsm) do
    """
          [
            function: :#{driver_lsm |> String.replace("()", "")},
            result: #{driver_lsm}
          ],
    """
  end

  defp get_driver_lsms(module, [func_info]) do
    get_driver_lsms(module, func_info)
  end

  defp get_driver_lsms(_module, %{impl: true, impl_drv: true} = func_info) do
    %{
      nif_name: nif_name
    } = func_info

    ["#{nif_name}_nif_driver_lsm_double()", "#{nif_name}_nif_driver_lsm_i64()"]
  end

  defp get_driver_lsms(_, _) do
    []
  end

  defp generate_functions(module) do
    Db.get_functions()
    |> Enum.map(&generate_function(module, &1))
    |> List.to_string()
  end

  defp generate_function(module, [func_info]) do
    generate_function(module, func_info)
  end

  defp generate_function(module, %{impl: true} = func_info) do
    %{
      nif_name: nif_name,
      module: _,
      function: _,
      arg_num: num,
      impl_drv: exist_driver?
    } = func_info

    args = generate_string_arguments(num)
    args_active = generate_string_arguments_active(num)
    args_inspect = generate_string_arguments_inspect(num)

    driver =
      if exist_driver? do
        """
          def #{nif_name}_nif_driver_double(_size), do: raise "NIF #{nif_name}_nif_driver_double/1 not implemented"

          def #{nif_name}_nif_driver_i64(_size), do: raise "NIF #{nif_name}_nif_driver_i64/1 not implemented"

          def #{nif_name}_nif_driver_lsm_double(), do: raise "NIF #{nif_name}_nif_driver_lsm_double/0 not implemented"

          def #{nif_name}_nif_driver_lsm_i64(), do: raise "NIF #{nif_name}_nif_driver_lsm_i64/0 not implemented"
        """
      else
        ""
      end

    """
      def #{nif_name}(#{args_active}) do
        try do
          #{nif_name}_nif(#{args_active})
        catch
          :error, :badarg ->
            runtime_info = try do
              :ets.lookup(:cpu_info, :runtime_info)
            catch
              :error, :badarg ->
                init_cpu_info()
                :ets.lookup(:cpu_info, :runtime_info)
            end
            if Pelemay.Db.get_flag(:put_error_log) do
              Logger.error("[Pelemay] badarg on #{Generator.nif_module(module)}.#{nif_name}")
              Logger.error("[Pelemay] args: #{args_inspect}")
            end
            try do
              if Pelemay.Db.get_flag(:put_error_log) do
                Logger.error("[Pelemay] compile_time_info = \#{Pelemay.eval_compile_time_info() |> elem(1) |> Keyword.get(:compile_time_info) |> inspect}")
              end
            rescue
              _e in Code.LoadError -> 
                if Pelemay.Db.get_flag(:put_error_log) do
                  Logger.error("[Pelemay] compile_time_info = nil")
                end
            end
            if Pelemay.Db.get_flag(:put_error_log) do
              Logger.error("[Pelemay] runtime_info = #\{runtime_info |> inspect}")
            end
            :erlang.error(:badarg)
        end
      end

      def #{nif_name}_nif(#{args}), do: raise "NIF #{nif_name}_nif/#{num} not implemented"

    #{driver}
    """
  end

  defp generate_function(_module, %{impl: false}) do
    ""
  end

  defp generate_function(_module, []), do: []

  defp generate_string_arguments(num) do
    1..num
    |> Enum.reduce(
      "",
      fn
        x, "" -> "_arg#{x}"
        x, acc -> acc <> ", _arg#{x}"
      end
    )
  end

  defp generate_string_arguments_active(num) do
    1..num
    |> Enum.reduce(
      "",
      fn
        x, "" -> "arg#{x}"
        x, acc -> acc <> ", arg#{x}"
      end
    )
  end

  def generate_string_arguments_inspect(num) do
    1..num
    |> Enum.reduce(
      "",
      fn
        x, "" -> "arg#{x} = \#{arg#{x} |> inspect}"
        x, acc -> acc <> ", arg#{x} = \#{arg#{x} |> inspect}"
      end
    )
  end
end
