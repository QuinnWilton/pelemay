defmodule Pelemay.Generator.Native.Enum do
  alias Pelemay.Generator, as: Generator
  alias Pelemay.Generator.Native.Util, as: Util
  alias Pelemay.Db

  def map(info) do
    %{
      nif_name: nif_name,
      args: [
        func: %{
          args: args,
          operators: operators
        }
      ]
    } = info

    expr_d = Util.make_expr(operators, args, "double")
    expr_l = Util.make_expr(operators, args, "long")

    Util.push_impl_info(info, true)

    kernel_h = """
    // Generated by Pelemay.Generator.Native.Enum
    #ifdef #{Generator.kernel_h_macro(nif_name)}
    #define #{Generator.kernel_h_macro(nif_name)}
    #ifdef __cplusplus
    extern "C" {
    #endif // __cplusplus
    void #{Generator.kernel_name(nif_name)}_double(double *vec_double, size_t vec_l);
    void #{Generator.kernel_name(nif_name)}_i64(double *vec_double, size_t vec_l);
    #ifdef __cplusplus
    }
    #endif // __cplusplus
    #endif // #{Generator.kernel_h_macro(nif_name)}
    """

    File.write!(Generator.full_path_kernel_h(nif_name), kernel_h)

    kernel_c = """
    // Generated by Pelemay.Generator.Native.Enum
    #include <erl_nif.h>
    #include <basic.h>
    #include "#{Generator.kernel_h(nif_name)}"

    #ifdef __cplusplus
    extern "C" {
    #endif // __cplusplus

    void #{Generator.kernel_name(nif_name)}_double(double *vec_double, size_t vec_l)
    {
    #pragma clang loop vectorize_width(LOOP_VECTORIZE_WIDTH)
      for(size_t i = 0; i < vec_l; i++) {
        vec_double[i] = #{expr_d};
      }      
    }

    void #{Generator.kernel_name(nif_name)}_i64(ErlNifSInt64 *vec_long, size_t vec_l)
    {
    #pragma clang loop vectorize_width(LOOP_VECTORIZE_WIDTH)
      for(size_t i = 0; i < vec_l; i++) {
        vec_long[i] = #{expr_l};
      }      
    }

    #ifdef __cplusplus
    }
    #endif // __cplusplus
    """

    File.write!(Generator.full_path_kernel_c(nif_name), kernel_c)

    Db.append_kernel(nif_name)

    """
    #include "#{Generator.kernel_h(nif_name)}"

    static ERL_NIF_TERM
    #{nif_name}_nif(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
    {
      if (__builtin_expect((argc != 1), false)) {
        return enif_make_badarg(env);
      }
      ErlNifSInt64 *vec_long;
      size_t vec_l;
      double *vec_double;
      if (__builtin_expect((enif_get_int64_vec_from_list(env, argv[0], &vec_long, &vec_l) == FAIL), false)) {
        if (__builtin_expect((enif_get_double_vec_from_list(env, argv[0], &vec_double, &vec_l) == FAIL), false)) {
          return enif_make_badarg(env);
        }
        #{Generator.kernel_name(nif_name)}_double(vec_double, vec_l);
        return enif_make_list_from_double_vec(env, vec_double, vec_l);
      }
      #{Generator.kernel_name(nif_name)}_i64(vec_long, vec_l);
      return enif_make_list_from_int64_vec(env, vec_long, vec_l);
    }
    """
  end

  def chunk_every(info) do
    %{
      nif_name: nif_name,
      module: _,
      function: _,
      arg_num: _,
      args: _
    } = info

    {:ok, ret} = File.read(__DIR__ <> "/enum.c")

    Map.update(info, :impl, nil, fn _ -> true end)
    |> Map.update(:arg_num, nil, fn _ -> 2 end)
    |> Db.register()

    String.replace(ret, "chunk_every", "#{nif_name}_nif")
  end

  # Add here
  def sort(info) do
    Util.push_impl_info(info, false)

    nil
  end

  def filter(info) do
    Util.push_impl_info(info, false)

    nil
  end
end
